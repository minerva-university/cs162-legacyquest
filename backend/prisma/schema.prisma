// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

// =============================================================================
// Schema Configuration
// =============================================================================

generator client {
  provider        = "prisma-client-js"   // Specifies Prisma Client for JavaScript/TypeScript
  previewFeatures = ["driverAdapters"] // Enables features like the Neon serverless driver adapter
  // output          = "../generated/prisma" // REMOVED: Use default node_modules/.prisma/client location
}

datasource db {
  provider = "postgresql"            // Database provider (PostgreSQL for Neon)
  url      = env("DATABASE_URL")     // Database connection URL from .env file
}

// =============================================================================
// ENUM Definitions
// =============================================================================

/// Defines the possible statuses for a task submission.
enum SubmissionStatus {
  Submitted // Initial status when user submits evidence
  Approved  // Status when a reviewer approves the submission
  Rejected  // Status when a reviewer rejects the submission
}

// =============================================================================
// Model: Legacy
// Represents a "Legacy" group within the application.
// =============================================================================
model Legacy {
  legacy_id       Int      @id @default(autoincrement()) // Primary key
  name            String   @unique @db.VarChar(255)       // Unique name of the legacy
  location_filter String?  @db.VarChar(255)               // Optional filter for location-based rankings/features
  points          Int      @default(0)                   // Total points accumulated by the legacy
  created_at      DateTime @default(now())               // Timestamp of creation
  updated_at      DateTime @updatedAt                    // Timestamp of last update

  // Relation: A Legacy can have many Users.
  // This is the inverse side of the one-to-many relation with User (legacy field).
  users User[]

  @@map("legacies") // Maps this model to the "legacies" table in the database
  @@index([points(sort: Desc)], name: "idx_legacies_points") // Index for efficient sorting/querying by points
  @@index([location_filter], name: "idx_legacies_location") // Index for filtering by location
  @@index([name], name: "idx_legacies_name") // Index for filtering/searching by name
}

// =============================================================================
// Model: Cohort
// Represents a user cohort (e.g., based on start date).
// =============================================================================
model Cohort {
  cohort_id  Int      @id @default(autoincrement()) // Primary key
  name       String   @unique @db.VarChar(100)    // Unique name of the cohort (e.g., "M24")
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  // Relation: A Cohort can have many Users.
  // Inverse side of the one-to-many relation with User (cohort field).
  users User[]

  @@map("cohorts")
}

// =============================================================================
// Model: Task
// Represents a task that can be assigned to users.
// =============================================================================
model Task {
  task_id            Int              @id @default(autoincrement())
  title              String           @db.VarChar(255)
  description        String?          @db.Text
  due_date           DateTime?        @db.Date
  points_on_approval Int              @default(0)
  location           String?          @db.VarChar(255) // This will match Legacy.location_filter
  created_at         DateTime         @default(now())
  updated_at         DateTime         @updatedAt

  submissions        TaskSubmission[]

  @@map("tasks")
  @@index([location], name: "idx_tasks_location")
  @@index([due_date], name: "idx_tasks_due_date")
}

// =============================================================================
// Model: User
// Represents an application user, linking Firebase Auth to local data.
// =============================================================================
model User {
  user_id             Int      @id @default(autoincrement()) // Primary key for internal use
  // --- Authentication & Core Info ---
  firebase_uid        String   @unique @db.VarChar(128)       // **KEY FIELD**: Unique ID from Firebase Authentication. Links this record to Firebase.
  email               String   @unique @db.VarChar(255)       // User's email address (synced from Firebase). Enforced unique.
  email_verified      Boolean? @default(false)                // Whether the email was verified by Firebase.
  full_name           String?  @db.VarChar(255)               // User's full name (synced from Firebase, but preserved on link if exists).
  profile_picture_url String?  @db.VarChar(512)               // URL to the user's profile picture (synced from Firebase).
  disabled            Boolean? @default(false)                // Flag to disable user access (application level).
  role                String   @default("student") @db.VarChar(50) // Application-specific role (e.g., student, admin, reviewer).

  // --- Application Specific Associations ---
  legacy_id           Int?                                    // Foreign key linking to the Legacy table.
  cohort_id           Int?                                    // Foreign key linking to the Cohort table.

  // --- Timestamps ---
  created_at          DateTime @default(now())
  updated_at          DateTime @updatedAt

  // --- Relations ---
  // Relation: A User belongs to one Legacy (optional).
  // onDelete: SetNull means if the Legacy is deleted, user.legacy_id becomes null.
  legacy              Legacy?          @relation(fields: [legacy_id], references: [legacy_id], onDelete: SetNull)
  // Relation: A User belongs to one Cohort (optional).
  // onDelete: SetNull means if the Cohort is deleted, user.cohort_id becomes null.
  cohort              Cohort?          @relation(fields: [cohort_id], references: [cohort_id], onDelete: SetNull)
  // Relation: A User can have many TaskSubmissions.
  submissions         TaskSubmission[] @relation("UserSubmissions") // Named relation for clarity
  // Relation: A User can be the reviewer for many TaskSubmissions.
  reviews_by_user     TaskSubmission[] @relation("ReviewerSubmissions") // Named relation for clarity

  @@map("users") // Maps to the "users" table
  // Unique index on email is automatically created by the @unique directive.
  // Unique index on firebase_uid is automatically created by the @unique directive.
  @@index([legacy_id], name: "idx_users_legacy_id")
  @@index([cohort_id], name: "idx_users_cohort_id")
}

// =============================================================================
// Model: TaskSubmission
// Represents a user's submission for a specific task.
// =============================================================================
model TaskSubmission {
  submission_id       Int              @id @default(autoincrement()) // Primary key
  // --- Foreign Keys & Core Info ---
  task_id             Int                                           // Links to the Task being submitted for
  user_id             Int                                           // Links to the User who made the submission
  status              SubmissionStatus @default(Submitted)           // Current status of the submission
  submitted_evidence  String?          @db.Text                     // Content of the evidence submitted by the user
  submitted_at        DateTime         @default(now())              // Timestamp when the submission was created/submitted
  is_latest           Boolean          @default(true)               // Flag to easily identify the most recent submission for a user/task pair

  // --- Review Information ---
  reviewed_by_user_id Int?                                          // Foreign key linking to the User who reviewed this submission
  reviewed_at         DateTime?                                     // Timestamp when the review occurred
  reviewer_comment    String?          @db.Text                     // Optional comments from the reviewer


  // --- Relations ---
  // Relation: A Submission belongs to one Task.
  // onDelete: Cascade means if the Task is deleted, this submission is also deleted.
  task                Task             @relation(fields: [task_id], references: [task_id], onDelete: Cascade)
  // Relation: A Submission belongs to one User (the submitter).
  // onDelete: Cascade means if the User is deleted, this submission is also deleted.
  user                User             @relation("UserSubmissions", fields: [user_id], references: [user_id], onDelete: Cascade)
  // Relation: A Submission is reviewed by one User (optional, the reviewer).
  // onDelete: SetNull means if the reviewer User is deleted, reviewed_by_user_id becomes null.
  reviewed_by_user    User?            @relation("ReviewerSubmissions", fields: [reviewed_by_user_id], references: [user_id], onDelete: SetNull)

  @@map("task_submissions") // Maps to the "task_submissions" table
  // --- Indexes for efficient querying ---
  @@index([task_id], name: "idx_submissions_task_id")
  @@index([user_id], name: "idx_submissions_user_id")
  @@index([reviewed_by_user_id], name: "idx_submissions_reviewed_by")
  @@index([status], name: "idx_submissions_status")
  // Compound index useful for finding the latest submission for a user/task quickly
  @@index([user_id, task_id, is_latest(sort: Desc), submitted_at(sort: Desc)], name: "idx_submissions_user_task_latest")
}